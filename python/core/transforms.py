from mlir.ir import *

from .search_vars import *
from .transform import Transform

import mlir.all_passes_registration


class Print(Transform):
  """Print intermediate IR.

  Dump the module and do not change it. The transform can be configured as
  follows:
  * `name`: Printer name.
  """

  def __init__(self, name=''):
    self.name = name

  def __call__(self, module: Module, fun_name: str):
    print('[[[ IR printer: ' + self.name + ' ]]]')
    module.dump()
    return module


class ExperimentalSplitAndFuseFillOp(Transform):
  """Tile and fuse FillOp into the output of reduction.

  This transform can be configured as follows:
  * `tile_sizes`: Tile sizes used for tiling.
  """

  def __init__(self, fun_name: str, op_name: str, tile_sizes=[], **kwargs):
    if tile_sizes:
      tile_str = f'tile-sizes={",".join([str(ts) for ts in tile_sizes])}'
    pipeline = (f'linalg-fuse-fill-into-reduction{{'
                f'     anchor-func={fun_name} '
                f'     anchor-op={op_name} '
                f'     {tile_str}}},'
                f'canonicalize,'
                f'cse')
    self.pipeline = (f'builtin.func({pipeline})')


class Inject(Transform):
  """Inject intermediate IR.

  Replace the module by the provided IR. The transform can be configured as
  follows:
  * `ir`: Textual IR to inject.
  """

  def __init__(self, ir: str):
    self.ir = ir

  def __call__(self, module: Module, fun_name: str, **kwargs):
    return Module.parse(self.ir)


class Fuse(Transform):
  """Tile a linalg op and fuse its producers.

  This transform can be configured as follows:
  * `tile_sizes`: Tile sizes used for tiling.
  * `tile_interchange`: Interchange used for tiling.
  """

  variables = {
      'tile_sizes': TilingSizesVariable,
      'tile_interchange': InterchangeVariable,
      'pad': BoolVariable,
  }

  def __init__(self, fun_name: str, op_name: str, **kwargs):
    self._parse_variables_in_kwargs(kwargs, {
        'tile_sizes': [],
        'tile_interchange': [],
        'pad': False
    })
    tile_str = ''
    interchange_str = ''
    if self.tile_sizes:
      tile_str = f'tile-sizes={",".join([str(ts) for ts in self.tile_sizes])}'
    if self.tile_interchange:
      dims = [str(ic) for ic in self.tile_interchange]
      interchange_str = f'tile-interchange={",".join(dims)}'
    pipeline = (f'linalg-fuse{{'
                f'     anchor-func={fun_name} '
                f'     anchor-op={op_name} '
                f'     {tile_str} '
                f'     {interchange_str}}},'
                f'canonicalize,'
                f'cse')
    self.pipeline = (f'builtin.func({pipeline})')


class Tile(Transform):
  """Tile a linalg op with `tile_sizes`.

  This transform can be configured as follows:
  * `tile_sizes`: Tile sizes used for tiling.
  * `tile_interchange`: Interchange used for tiling.
  * `peel`: Peel the specified loops generated by the tiling pattern. Cannot be
     used together with `pad`.
  * `pad`: Pad the operands.
  * `pack_paddings`: Pack the padded operand if the packing flag is set. `pad`
     must also be specified.
  * `hoist_paddings`: Hoist the padded operand by the specified number of loops.
     pad` must also be specified.
  * `scalarize_dyn_dims`: Scalarize all dimensions that having statically
    unknown size. Either `tile_sizes` or `scalarize_dyn_dims` must be specified.
    Cannot use both at the same time. Cannot be used together with `pad` or
    `peel`.
  """

  variables = {
      'tile_sizes': TilingSizesVariable,
      'tile_interchange': InterchangeVariable,
      'pad': BoolVariable,
      'peel': PeelingVariable,
      'pack_paddings': PackPaddingVariable,
      'hoist_paddings': HoistPaddingVariable,
  }

  def __init__(
      self,
      fun_name: str,
      op_name: str,
      # TODO: move this to a tunable variable.
      scalarize_dyn_dims=False,
      **kwargs):
    self._parse_variables_in_kwargs(
        kwargs, {
            'tile_sizes': [],
            'tile_interchange': [],
            'pad': False,
            'peel': [],
            'pack_paddings': [],
            'hoist_paddings': []
        })
    tile_str = ''
    interchange_str = ''
    pad_str = ''
    peeled_loops_str = ''
    scalarize_dyn_dims_str = ''

    if self.tile_sizes:
      tile_str = f'tile-sizes={",".join([str(ts) for ts in self.tile_sizes])}'
    if self.tile_interchange:
      dims = [str(ic) for ic in self.tile_interchange]
      interchange_str = f'tile-interchange={",".join(dims)}'
    if self.pad:
      packing_flags = [str(pp) for pp in self.pack_paddings]
      hoisting_depths = [str(hd) for hd in self.hoist_paddings]
      pad_str = f'pad'
      if packing_flags:
        pad_str = pad_str + f' pack-paddings={",".join(packing_flags)}'
      if hoisting_depths:
        pad_str = pad_str + f' hoist-paddings={",".join(hoisting_depths)}'
    if self.peel:
      loop_indices = [str(l) for l in self.peel]
      peeled_loops_str = f'peeled-loops={",".join(loop_indices)}'
    if scalarize_dyn_dims:
      scalarize_dyn_dims_str = 'scalarize-dynamic-dims'

    pipeline = (f'linalg-tensor-codegen-driver{{'
                f'     anchor-func={fun_name} '
                f'     anchor-op={op_name} '
                f'     {tile_str} '
                f'     {interchange_str} '
                f'     {peeled_loops_str} '
                f'     {scalarize_dyn_dims_str} '
                f'     {pad_str}}},'
                f'canonicalize,'
                f'cse')
    self.pipeline = (f'builtin.func({pipeline})')


class Vectorize(Transform):

  def __init__(self, fun_name: str, op_name: str, **kwargs):
    pipeline = (f'linalg-tensor-codegen-driver{{'
                f'     anchor-func={fun_name} '
                f'     anchor-op={op_name} '
                f'     vectorize '
                f'     vectorize-padding}},'
                f'canonicalize,'
                f'cse')
    self.pipeline = (f'builtin.func({pipeline})')


class Generalize(Transform):
  """Transform a named operation to its generic form.

  This transform can be configured as follows:
  * `iterator_interchange`: Interchange the iterators of the generic operation.

  Note: After generalization the anchor op name changes to 'linalg.generic'.
  """

  variables = {
      'iterator_interchange': InterchangeVariable,
  }

  def __init__(self, fun_name: str, op_name: str, **kwargs):
    self._parse_variables_in_kwargs(kwargs, {'iterator_interchange': []})
    interchange_str = ''

    if self.iterator_interchange:
      dims = [str(ic) for ic in self.iterator_interchange]
      interchange_str = f'iterator-interchange={",".join(dims)}'

    pipeline = (f'linalg-tensor-codegen-driver{{'
                f'     anchor-func={fun_name} '
                f'     anchor-op={op_name} '
                f'     generalize '
                f'     {interchange_str}}}')
    self.pipeline = (f'builtin.func({pipeline})')


class DecomposeToLowerDimensionalNamedOp(Transform):
  """Rewrite all known named ops to a lower-dimensional form suitable for

     vectorization.

    TODO: atm this is applied to all supported ops. If/when we need finer
    control this should be exposed with an opName + filter and a proper
    pattern.
  """

  def __init__(self, **kwargs):
    pipeline = (f'linalg-tensor-codegen-driver{{'
                f'     decompose-to-lower-dim }}')
    self.pipeline = (f'builtin.func({pipeline})')


class Bufferize(Transform):

  def __init__(self, **kwargs):
    pipeline = (f'linalg-bufferization-driver,' f'canonicalize,' f'cse')
    self.pipeline = pipeline


class LowerVectors(Transform):

  def __init__(self, stage, **kwargs):
    contraction_lowering = 'outerproduct' if 'contraction_lowering' not in \
        kwargs else kwargs['contraction_lowering']
    multi_reduction_lowering = 'innerparallel' if 'multi_reduction_lowering' \
        not in kwargs else kwargs['multi_reduction_lowering']
    transpose_lowering = 'eltwise' if 'transpose_lowering' not in \
        kwargs else kwargs['transpose_lowering']
    transpose_avx2_lowering = False if ('transpose_avx2_lowering' not in \
        kwargs or not kwargs['transpose_lowering']) else True
    pipeline = (
        f'linalg-vector-lowering{{'
        f'    lower-vector-stage={stage}'
        f'    max-transfer-rank=1 '
        f'    split-transfers=linalg-copy '
        f'    lower-vector-transpose-to={transpose_lowering} '
        f'    lower-vector-transpose-to-avx2={transpose_avx2_lowering} '
        f'    lower-vector-multi-reduction-to={multi_reduction_lowering} '
        f'    lower-vector-contraction-to={contraction_lowering} '
        f'    unroll-vector-transfers=true}},'
        f'canonicalize,'
        f'cse')
    self.pipeline = (f'builtin.func({pipeline})')


class LowerToLLVM(Transform):

  def __init__(self, **kwargs):
    pipeline = (f'llvm-lowering,' f'canonicalize,' f'cse')
    self.pipeline = pipeline


class Sparsify(Transform):

  def __init__(self, options: str):
    pipeline = (
        f'sparsification{{{options}}},'
        f'sparse-tensor-conversion,'
        f'builtin.func(convert-linalg-to-loops,convert-vector-to-scf),'
        f'convert-scf-to-std,'
        f'func-bufferize,'
        f'tensor-constant-bufferize,'
        f'builtin.func(tensor-bufferize,std-bufferize,finalizing-bufferize),'
        f'convert-vector-to-llvm{{reassociate-fp-reductions=1 enable-index-optimizations=1}},'
        f'lower-affine,'
        f'convert-memref-to-llvm,'
        f'convert-std-to-llvm,'
        f'reconcile-unrealized-casts')
    self.pipeline = pipeline
